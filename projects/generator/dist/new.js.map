{
  "version": 3,
  "sources": ["../src/new.ts", "../src/config.ts"],
  "sourcesContent": ["import fs from 'fs/promises'\n\nimport { loadConfig, loadInterface } from './config'\n\nfunction parseFuncPtr(type: string) {\n  const mat = /^\\s*([^(]+?)?\\s*\\(\\*\\)\\(([\\s\\S]*)\\)$/.exec(type)\n  if (!mat) {\n    throw 'bad func ptr type ' + type\n  }\n  const ret = mat[1]!\n  const args_list = mat[2]!\n  // TODO: allow func ptr inside arg\n  const args = args_list.split(',')\n  return {\n    ret,\n    args\n  }\n}\n\nasync function main() {\n  let interface_path = process.argv[2] ?? '../interface.json'\n  let config_path = process.argv[3] ?? '../config.json'\n  let output_path = process.argv[4] ?? '../info.hpp'\n\n  const int = await loadInterface(interface_path)\n  const cfg = await loadConfig(config_path)\n\n  int.interface = int.interface.filter(x => {\n    for (const rule of cfg.remove) {\n      if (rule.startsWith('/')) {\n        if (new RegExp(rule.slice(1)).exec(x.name)) {\n          return false\n        }\n      } else {\n        if (rule === x.name) {\n          return false\n        }\n      }\n    }\n    return true\n  })\n\n  const result: string[] = []\n\n  result.push('// clang-format off')\n  result.push('#pragma once')\n  result.push('')\n  result.push('#include \"general/call.hpp\"')\n  result.push('#include \"general/callback.hpp\"')\n  result.push('')\n  if (cfg.header) {\n    for (const hdr of cfg.header) {\n      result.push(`#include \"${hdr}\"`)\n    }\n    result.push('')\n  }\n\n  for (const info of int.interface) {\n    result.push(`namespace lhg::${cfg.name} {`)\n    result.push('')\n    result.push(`struct func_type_${info.name} {`)\n    for (const [idx, arg] of info.argument.entries()) {\n      result.push(`  struct _${idx}_${arg.name} {`)\n      result.push(`    constexpr static size_t index = ${idx};`)\n      result.push(`    constexpr static const char* name = \"${arg.name}\";`)\n      result.push(`    using type = ${arg.type};`)\n      result.push('  };')\n    }\n    result.push(`  struct ret {`)\n    result.push(`    constexpr static size_t index = ${info.argument.length};`)\n    result.push(`    constexpr static const char* name = \"return\";`)\n    result.push(`    using type = ${info.return};`)\n    result.push('  };')\n    result.push(\n      `  using args = std::tuple<${info.argument\n        .map((v, i) => `_${i}_${v.name}`)\n        .concat(['ret'])\n        .join(', ')}>;`\n    )\n\n    result.push('};')\n\n    result.push(`struct function_${info.name} {`)\n    result.push(`  constexpr static auto func = ${info.name};`)\n    result.push(`  constexpr static const char* name = \"${info.name}\";`)\n    result.push(`  using type = func_type_${info.name};`)\n    result.push('};')\n    result.push('')\n\n    result.push('}')\n    result.push('namespace lhg::traits {')\n    result.push('')\n\n    result.push('template<>')\n    result.push(`inline constexpr bool is_input<${cfg.name}::func_type_${info.name}::ret> = false;`)\n    result.push('template<>')\n    result.push(`inline constexpr bool is_output<${cfg.name}::func_type_${info.name}::ret> = true;`)\n\n    result.push('')\n    result.push('}')\n    result.push('')\n  }\n\n  result.push(`namespace lhg::${cfg.name} {`)\n  result.push('')\n  result.push(`using __function_list = std::tuple<\n${int.interface.map(info => `  function_${info.name}`).join(',\\n')}\n>;`)\n  result.push('')\n  result.push('}')\n\n  for (const [type, info] of Object.entries(cfg.callback)) {\n    result.push(`namespace lhg::${cfg.name} {`)\n    result.push('')\n\n    const { ret, args } = parseFuncPtr(type)\n    result.push(`struct func_type_${info.name} {`)\n\n    for (const [idx, arg] of args.entries()) {\n      result.push(`  struct _${idx}_${info.arg_name[idx]} {`)\n      result.push(`    constexpr static size_t index = ${idx};`)\n      result.push(`    constexpr static const char* name = \"${info.arg_name[idx]}\";`)\n      result.push(`    using type = ${arg};`)\n      result.push('  };')\n    }\n\n    result.push(`  struct ret {`)\n    result.push(`    constexpr static size_t index = ${args.length};`)\n    result.push(`    constexpr static const char* name = \"return\";`)\n    result.push(`    using type = ${ret};`)\n    result.push('  };')\n    result.push(\n      `  using args = std::tuple<${info.arg_name\n        .map((v, i) => `_${i}_${v}`)\n        .concat(['ret'])\n        .join(', ')}>;`\n    )\n\n    result.push(\n      `};\nstruct callback_${info.name} {\n  using type = func_type_${info.name};\n  using func_type = ${type};\n  constexpr static size_t context = ${info.self};\n  constexpr static const char* name = \"${info.name}\";\n};`\n    )\n\n    result.push('')\n    result.push(`}`)\n    result.push('namespace lhg::traits {')\n    result.push('')\n\n    result.push('template<>')\n    result.push(\n      `inline constexpr bool is_input<${cfg.name}::func_type_${info.name}::_${info.self}_> = false;`\n    )\n    result.push('template<>')\n    result.push(`inline constexpr bool is_input<${cfg.name}::func_type_${info.name}::ret> = false;`)\n    result.push('template<>')\n    result.push(`inline constexpr bool is_output<${cfg.name}::func_type_${info.name}::ret> = true;`)\n\n    result.push('')\n    result.push('}')\n    result.push('')\n  }\n\n  result.push(`namespace lhg::${cfg.name} {`)\n  result.push('')\n  result.push(\n    `using __callback_list = std::tuple<\n${Object.entries(cfg.callback)\n  .map(info => `  callback_${info[1].name}`)\n  .join(',\\n')}\n>;`\n  )\n  result.push('')\n  result.push('}')\n  result.push('')\n\n  for (const opaque in cfg.opaque) {\n    result.push(\n      `namespace lhg::traits {\n\ntemplate<>\ninline constexpr bool type_is_handle<${opaque} *> = true;\n\ntemplate<>\ninline const constexpr char* type_handle_name<${opaque} *> = \"${opaque}\";\n\n}\n`\n    )\n  }\n\n  result.push(`namespace lhg::${cfg.name} {`)\n  result.push('')\n  result.push(\n    `using __handle_list = std::tuple<${Object.keys(cfg.opaque)\n      .map(info => `${info}*`)\n      .join(', ')}>;`\n  )\n  result.push('')\n  result.push('}')\n  result.push('')\n\n  fs.writeFile(output_path, result.join('\\n'))\n}\n\nmain()\n", "import fs from 'fs/promises'\nimport path from 'path'\n\nimport { LHGConfig, LHGInterface } from './types'\n\nexport async function loadConfig(config_path: string) {\n  const obj = JSON.parse(await fs.readFile(config_path, 'utf-8')) as LHGConfig\n  return {\n    name: obj.name ?? 'unknown',\n    header: obj.header ?? [],\n    callback: obj.callback ?? {},\n    opaque: obj.opaque ?? {},\n    output: obj.output ?? [],\n    remove: obj.remove ?? [],\n    check: obj.check ?? {}\n  }\n}\n\nexport async function loadInterface(interface_path: string) {\n  return JSON.parse(await fs.readFile(interface_path, 'utf-8')) as LHGInterface\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,mBAAe;;;ACAf,sBAAe;AAKf,eAAsB,WAAW,aAAqB;AACpD,QAAM,MAAM,KAAK,MAAM,MAAM,gBAAAC,QAAG,SAAS,aAAa,OAAO,CAAC;AAC9D,SAAO;AAAA,IACL,MAAM,IAAI,QAAQ;AAAA,IAClB,QAAQ,IAAI,UAAU,CAAC;AAAA,IACvB,UAAU,IAAI,YAAY,CAAC;AAAA,IAC3B,QAAQ,IAAI,UAAU,CAAC;AAAA,IACvB,QAAQ,IAAI,UAAU,CAAC;AAAA,IACvB,QAAQ,IAAI,UAAU,CAAC;AAAA,IACvB,OAAO,IAAI,SAAS,CAAC;AAAA,EACvB;AACF;AAEA,eAAsB,cAAc,gBAAwB;AAC1D,SAAO,KAAK,MAAM,MAAM,gBAAAA,QAAG,SAAS,gBAAgB,OAAO,CAAC;AAC9D;;;ADhBA,SAAS,aAAa,MAAc;AAClC,QAAM,MAAM,uCAAuC,KAAK,IAAI;AAC5D,MAAI,CAAC,KAAK;AACR,UAAM,uBAAuB;AAAA,EAC/B;AACA,QAAM,MAAM,IAAI,CAAC;AACjB,QAAM,YAAY,IAAI,CAAC;AAEvB,QAAM,OAAO,UAAU,MAAM,GAAG;AAChC,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,eAAe,OAAO;AACpB,MAAI,iBAAiB,QAAQ,KAAK,CAAC,KAAK;AACxC,MAAI,cAAc,QAAQ,KAAK,CAAC,KAAK;AACrC,MAAI,cAAc,QAAQ,KAAK,CAAC,KAAK;AAErC,QAAM,MAAM,MAAM,cAAc,cAAc;AAC9C,QAAM,MAAM,MAAM,WAAW,WAAW;AAExC,MAAI,YAAY,IAAI,UAAU,OAAO,OAAK;AACxC,eAAW,QAAQ,IAAI,QAAQ;AAC7B,UAAI,KAAK,WAAW,GAAG,GAAG;AACxB,YAAI,IAAI,OAAO,KAAK,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,GAAG;AAC1C,iBAAO;AAAA,QACT;AAAA,MACF,OAAO;AACL,YAAI,SAAS,EAAE,MAAM;AACnB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT,CAAC;AAED,QAAM,SAAmB,CAAC;AAE1B,SAAO,KAAK,qBAAqB;AACjC,SAAO,KAAK,cAAc;AAC1B,SAAO,KAAK,EAAE;AACd,SAAO,KAAK,6BAA6B;AACzC,SAAO,KAAK,iCAAiC;AAC7C,SAAO,KAAK,EAAE;AACd,MAAI,IAAI,QAAQ;AACd,eAAW,OAAO,IAAI,QAAQ;AAC5B,aAAO,KAAK,aAAa,GAAG,GAAG;AAAA,IACjC;AACA,WAAO,KAAK,EAAE;AAAA,EAChB;AAEA,aAAW,QAAQ,IAAI,WAAW;AAChC,WAAO,KAAK,kBAAkB,IAAI,IAAI,IAAI;AAC1C,WAAO,KAAK,EAAE;AACd,WAAO,KAAK,oBAAoB,KAAK,IAAI,IAAI;AAC7C,eAAW,CAAC,KAAK,GAAG,KAAK,KAAK,SAAS,QAAQ,GAAG;AAChD,aAAO,KAAK,aAAa,GAAG,IAAI,IAAI,IAAI,IAAI;AAC5C,aAAO,KAAK,uCAAuC,GAAG,GAAG;AACzD,aAAO,KAAK,4CAA4C,IAAI,IAAI,IAAI;AACpE,aAAO,KAAK,oBAAoB,IAAI,IAAI,GAAG;AAC3C,aAAO,KAAK,MAAM;AAAA,IACpB;AACA,WAAO,KAAK,gBAAgB;AAC5B,WAAO,KAAK,uCAAuC,KAAK,SAAS,MAAM,GAAG;AAC1E,WAAO,KAAK,mDAAmD;AAC/D,WAAO,KAAK,oBAAoB,KAAK,MAAM,GAAG;AAC9C,WAAO,KAAK,MAAM;AAClB,WAAO;AAAA,MACL,6BAA6B,KAAK,SAC/B,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,EAC/B,OAAO,CAAC,KAAK,CAAC,EACd,KAAK,IAAI,CAAC;AAAA,IACf;AAEA,WAAO,KAAK,IAAI;AAEhB,WAAO,KAAK,mBAAmB,KAAK,IAAI,IAAI;AAC5C,WAAO,KAAK,kCAAkC,KAAK,IAAI,GAAG;AAC1D,WAAO,KAAK,0CAA0C,KAAK,IAAI,IAAI;AACnE,WAAO,KAAK,4BAA4B,KAAK,IAAI,GAAG;AACpD,WAAO,KAAK,IAAI;AAChB,WAAO,KAAK,EAAE;AAEd,WAAO,KAAK,GAAG;AACf,WAAO,KAAK,yBAAyB;AACrC,WAAO,KAAK,EAAE;AAEd,WAAO,KAAK,YAAY;AACxB,WAAO,KAAK,kCAAkC,IAAI,IAAI,eAAe,KAAK,IAAI,iBAAiB;AAC/F,WAAO,KAAK,YAAY;AACxB,WAAO,KAAK,mCAAmC,IAAI,IAAI,eAAe,KAAK,IAAI,gBAAgB;AAE/F,WAAO,KAAK,EAAE;AACd,WAAO,KAAK,GAAG;AACf,WAAO,KAAK,EAAE;AAAA,EAChB;AAEA,SAAO,KAAK,kBAAkB,IAAI,IAAI,IAAI;AAC1C,SAAO,KAAK,EAAE;AACd,SAAO,KAAK;AAAA,EACZ,IAAI,UAAU,IAAI,UAAQ,cAAc,KAAK,IAAI,EAAE,EAAE,KAAK,KAAK,CAAC;AAAA,GAC/D;AACD,SAAO,KAAK,EAAE;AACd,SAAO,KAAK,GAAG;AAEf,aAAW,CAAC,MAAM,IAAI,KAAK,OAAO,QAAQ,IAAI,QAAQ,GAAG;AACvD,WAAO,KAAK,kBAAkB,IAAI,IAAI,IAAI;AAC1C,WAAO,KAAK,EAAE;AAEd,UAAM,EAAE,KAAK,KAAK,IAAI,aAAa,IAAI;AACvC,WAAO,KAAK,oBAAoB,KAAK,IAAI,IAAI;AAE7C,eAAW,CAAC,KAAK,GAAG,KAAK,KAAK,QAAQ,GAAG;AACvC,aAAO,KAAK,aAAa,GAAG,IAAI,KAAK,SAAS,GAAG,CAAC,IAAI;AACtD,aAAO,KAAK,uCAAuC,GAAG,GAAG;AACzD,aAAO,KAAK,4CAA4C,KAAK,SAAS,GAAG,CAAC,IAAI;AAC9E,aAAO,KAAK,oBAAoB,GAAG,GAAG;AACtC,aAAO,KAAK,MAAM;AAAA,IACpB;AAEA,WAAO,KAAK,gBAAgB;AAC5B,WAAO,KAAK,uCAAuC,KAAK,MAAM,GAAG;AACjE,WAAO,KAAK,mDAAmD;AAC/D,WAAO,KAAK,oBAAoB,GAAG,GAAG;AACtC,WAAO,KAAK,MAAM;AAClB,WAAO;AAAA,MACL,6BAA6B,KAAK,SAC/B,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE,EAC1B,OAAO,CAAC,KAAK,CAAC,EACd,KAAK,IAAI,CAAC;AAAA,IACf;AAEA,WAAO;AAAA,MACL;AAAA,kBACY,KAAK,IAAI;AAAA,2BACA,KAAK,IAAI;AAAA,sBACd,IAAI;AAAA,sCACY,KAAK,IAAI;AAAA,yCACN,KAAK,IAAI;AAAA;AAAA,IAE9C;AAEA,WAAO,KAAK,EAAE;AACd,WAAO,KAAK,GAAG;AACf,WAAO,KAAK,yBAAyB;AACrC,WAAO,KAAK,EAAE;AAEd,WAAO,KAAK,YAAY;AACxB,WAAO;AAAA,MACL,kCAAkC,IAAI,IAAI,eAAe,KAAK,IAAI,MAAM,KAAK,IAAI;AAAA,IACnF;AACA,WAAO,KAAK,YAAY;AACxB,WAAO,KAAK,kCAAkC,IAAI,IAAI,eAAe,KAAK,IAAI,iBAAiB;AAC/F,WAAO,KAAK,YAAY;AACxB,WAAO,KAAK,mCAAmC,IAAI,IAAI,eAAe,KAAK,IAAI,gBAAgB;AAE/F,WAAO,KAAK,EAAE;AACd,WAAO,KAAK,GAAG;AACf,WAAO,KAAK,EAAE;AAAA,EAChB;AAEA,SAAO,KAAK,kBAAkB,IAAI,IAAI,IAAI;AAC1C,SAAO,KAAK,EAAE;AACd,SAAO;AAAA,IACL;AAAA,EACF,OAAO,QAAQ,IAAI,QAAQ,EAC1B,IAAI,UAAQ,cAAc,KAAK,CAAC,EAAE,IAAI,EAAE,EACxC,KAAK,KAAK,CAAC;AAAA;AAAA,EAEZ;AACA,SAAO,KAAK,EAAE;AACd,SAAO,KAAK,GAAG;AACf,SAAO,KAAK,EAAE;AAEd,aAAW,UAAU,IAAI,QAAQ;AAC/B,WAAO;AAAA,MACL;AAAA;AAAA;AAAA,uCAGiC,MAAM;AAAA;AAAA;AAAA,gDAGG,MAAM,UAAU,MAAM;AAAA;AAAA;AAAA;AAAA,IAIlE;AAAA,EACF;AAEA,SAAO,KAAK,kBAAkB,IAAI,IAAI,IAAI;AAC1C,SAAO,KAAK,EAAE;AACd,SAAO;AAAA,IACL,oCAAoC,OAAO,KAAK,IAAI,MAAM,EACvD,IAAI,UAAQ,GAAG,IAAI,GAAG,EACtB,KAAK,IAAI,CAAC;AAAA,EACf;AACA,SAAO,KAAK,EAAE;AACd,SAAO,KAAK,GAAG;AACf,SAAO,KAAK,EAAE;AAEd,mBAAAC,QAAG,UAAU,aAAa,OAAO,KAAK,IAAI,CAAC;AAC7C;AAEA,KAAK;",
  "names": ["import_promises", "fs", "fs"]
}
